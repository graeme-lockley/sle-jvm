export main

import file:../Control/Actor
import file:../Control/Actor/Response

import file:../Data/Bitwise
import file:../Data/List
import file:../Data/Option
import file:../Data/String

import file:./Unit

import file:../Debug as D


console =
  Actor.createBuiltin "za.co.no9.sle.runtime.actors.ConsoleActor"


type SuiteMsg
  = AddTest (Actor.Actor TestMsg)
  | AddSuite (Actor.Actor SuiteMsg)
  | TestComplete Int Unit.Suite
  | SuiteRegistered Int


type TestMsg
  = Register Int


staticTestActor : Actor.Actor SuiteMsg -> String -> Bool -> Actor.Actor TestMsg
staticTestActor suite name result =
  Actor.create
      (\self ->
        ( ()
        , [ Actor.cmd suite <| AddTest self
          ]
        )
      )
      (\state (Register id) ->
        Response.msg <| Actor.cmd suite <| TestComplete id (Unit.Test name result)
      )


typealias SuiteResult =
  { id : Int
  , result : Option Unit.Suite
  }


typealias SuiteState =
  { name : String
  , id : Option Int
  , idCounter : Int
  , results : List SuiteResult
  , parent : Option (Actor.Actor SuiteMsg)
  , self : Actor.Actor SuiteMsg
  }


formatSuiteHelper : Int -> Unit.Suite -> String
formatSuiteHelper indent (Unit.Test name value) =
  if value then
    String.concat
      [ String.repeat (indent * 2) " "
      , "\u001B[32m"
      , name
      , "\u001B[0m"
      ]
  else
    String.concat
      [ String.repeat (indent * 2) " "
      , "\u001B[31m"
      , name
      , "\u001B[0m"

      ]

formatSuiteHelper indent (Unit.Describe name suites) =
  String.concat
    [ String.repeat (indent * 2) " "
    , name
    , "\n"
    , String.join "\n" <| List.map (formatSuiteHelper (indent + 1)) suites
    ]


renderTestResult =
  Actor.createStateless (\m -> [Actor.cmd console <| formatSuiteHelper 0 m])


update : SuiteState -> SuiteMsg -> Actor.Response SuiteState
update state (AddTest test) =
  Response.stateMsgs
    { state | idCounter = state.idCounter + 1 , results = { id = state.idCounter, result = None } :: state.results }
    [ Actor.cmd test <| Register state.idCounter ]

update state (AddSuite test) =
  Response.stateMsgs
    { state | idCounter = state.idCounter + 1 , results = { id = state.idCounter, result = None } :: state.results }
    [ Actor.cmd test <| SuiteRegistered state.idCounter ]

update state (TestComplete id value) =
  let
    mapResult : SuiteResult -> SuiteResult
    mapResult testResult =
      if testResult.id == id then
        { testResult | result = Some value}
      else
        testResult

    results : List SuiteResult
    results =
      List.map mapResult state.results

    isSuiteResultDone : SuiteResult -> Bool
    isSuiteResultDone s =
      s.result != None

    done =
      List.all isSuiteResultDone results

    newState : SuiteState
    newState =
      D.info "newState" { state | results = results }

    suiteResultMap : SuiteResult -> Unit.Suite
    suiteResultMap sr =
      Option.withDefault (Unit.Test "Fred" True) sr.result

    msgs =
      if done then
        case newState.id of
          Some id ->
            case newState.parent of
              Some parent ->
                [ Actor.cmd parent <| TestComplete id <| Unit.Describe newState.name <| List.map suiteResultMap newState.results ]

              None ->
                D.error "Crap" []

          None ->
            let
              msg =
                  Unit.Describe newState.name
                  <| List.map suiteResultMap newState.results
            in
              [ Actor.cmd renderTestResult msg ]
      else
        []
  in
    msgs
      |> D.info (String.concat ["TestComplete - messages: ", newState.name ])
      |> Response.stateMsgs newState

update state (SuiteRegistered id) =
  { state | id = Some id }
    |> Response.state


init : String -> Option (Actor.Actor SuiteMsg) -> Actor.Actor SuiteMsg -> (SuiteState, List Actor.Cmd)

init name (Some parent) self =
  D.info "init blah" <|
  ( { name = name
    , id = None
    , idCounter = 0
    , results = []
    , parent = Some parent
    , self = self
    }
  , [ Actor.cmd parent <| AddSuite self ]
  )

init name None self =
  ( { name = name
    , id = None
    , idCounter = 0
    , results = []
    , parent = None
    , self = self
    }
  , [  ]
  )


root : String -> Actor.Actor SuiteMsg
root name =
  Actor.create (init name None) update


suite : String -> Actor.Actor SuiteMsg -> Actor.Actor SuiteMsg
suite name parent =
  Actor.create (init name (Some parent)) update



rt : String -> Bool -> Actor.Actor SuiteMsg -> ()
rt name value suite =
  let
    t =
      staticTestActor suite name value
  in
    ()


rd : String -> List (Actor.Actor SuiteMsg -> ()) -> Actor.Actor SuiteMsg -> ()
rd name items parent =
  let
    newSuite =
      suite name parent

    actorItems =
      List.map (\a -> a newSuite) items
  in
    ()

rr : String -> List (Actor.Actor SuiteMsg -> ()) -> Actor.Actor SuiteMsg
rr name items =
  let
    newRoot =
      root name

    actorItems =
      List.map (\a -> a newRoot) items
  in
    newRoot



main2 x =
    rr "Data.Bitwise"
      [ rd "and"
          [ rt "and with 32 bit integers" <| Bitwise.and 5 3 == 1
          , rt "and with 0 as first argument" <| Bitwise.and 0 1450 == 0
          , rd "or-ish"
              [ rt "with 32 bit integers" <| Bitwise.and 5 3 == 1
              , rt "with 0 as first argument" <| Bitwise.and 0 1450 == 0
              ]
          ]
      ]

main =
  let
    r =
      root "Data.Bitwise"

    andRoot =
      suite "and" r

    t1 =
      staticTestActor andRoot "and with 32 bit integers" <| Bitwise.and 5 3 == 1

    t2 =
      staticTestActor andRoot "and with 0 as first argument" <| Bitwise.and 0 1450 == 0

    orRoot =
      suite "or" andRoot

    t3 =
      staticTestActor orRoot "with 32 bit integers" <| Bitwise.and 5 3 == 1

    t4 =
      staticTestActor orRoot "with 0 as first argument" <| Bitwise.and 0 1450 == 0
  in
    r